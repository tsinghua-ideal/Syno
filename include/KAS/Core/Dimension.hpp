#pragma once

#include <algorithm>
#include <compare>
#include <string>
#include <vector>

#include "KAS/Core/Size.hpp"
#include "KAS/Utils/Common.hpp"


namespace kas {

enum class DimensionType {
// Repeat-like:
    Shift,
    Stride,
// Split-like:
    Split,
    Unfold,
// Merge-like:
    Merge,
    Share,
// Iterator:
    Iterator,
// Hidden iterators generated by MapReduce
    MapReduce,
};
std::string DimensionTypeDescription(DimensionType ty);

class DimensionImpl {
public:
    virtual const Size& size() const noexcept = 0;
    virtual std::size_t hash() const noexcept = 0;
    virtual DimensionType type() const noexcept = 0;
    virtual ~DimensionImpl() = default;
};

class Dimension;
using Interface = std::vector<Dimension>;

class Dimension {
public:
    using PointerType = const DimensionImpl *;
protected:
    // Require that same `DimensionImpl`s have same address, i.e., uniqued.
    PointerType inner;
    std::size_t hashValue;
public:
    inline Dimension(PointerType inner): inner { inner }, hashValue { inner->hash() } {}
    inline PointerType getInnerPointer() const noexcept { return inner; }
    inline const Size& size() const noexcept { return inner->size(); }
    inline DimensionType type() const noexcept { return inner->type(); }
    // Checks the underlying type of the dimension.
    inline bool is(DimensionType ty) const noexcept { return inner->type() == ty; }
    template<typename T>
    const T& as() const noexcept { return *dynamic_cast<const T *>(inner); }
    template<typename T>
    const T *tryAs() const noexcept { return dynamic_cast<const T *>(inner); }
    std::weak_ordering operator<=>(const Dimension& other) const noexcept {
        return hashValue <=> other.hashValue; // Use their hashes to sort the interface.
    }
    inline bool operator==(const Dimension& other) const {
        return inner == other.inner; // If the impls are equal, they have equal hash.
    }
    // Sort the dimensions in an interface to obtain hash for it.
    inline std::size_t hash() const noexcept { return hashValue; }
    std::string description(const BindingContext& ctx) const;

    Interface::const_iterator findIn(const Interface& interface) const;
};

} // namespace kas

template<>
struct std::hash<kas::Interface> {
    inline std::size_t operator()(const kas::Interface& interface) const noexcept {
        std::size_t h = interface.size();
        for (const auto& dim: interface) {
            kas::HashCombine(h, dim.hash());
        }
        return h;
    }
};

#pragma once

#include <algorithm>
#include <compare>
#include <ranges>
#include <string>
#include <vector>

#include "fmt/format.h"

#include "KAS/Core/Colors.hpp"
#include "KAS/Core/Shape.hpp"
#include "KAS/Core/Size.hpp"
#include "KAS/Utils/Common.hpp"


namespace kas {

enum class DimensionType {
// Iterator = 0:
    Iterator,
// Hidden iterators generated by MapReduce
    MapReduce,
// Repeat-like:
    Shift,
    Stride,
// Split-like:
    Split,
    Unfold,
// Merge-like:
    Merge,
    Share,
};

enum class DimensionTypeWithOrder {
    // Keep the 6 of them in the same order as DimensionType!
    Iterator = 0,
    MapReduce,
    Shift,
    Stride,
    Split,
    Unfold,
    // MergeLikeOp's are different.
    MergeL,
    MergeR,
    ShareL,
    ShareR,
};

// A dimension connects two Op's. So there is a certain direction when we are traversing the graph.
enum class Direction: bool {
    Down = false,
    Up = true,
};

// Used to differentiate LHS from RHS.
enum class Order: bool {
    Left = false,
    Right = true,
};

class DimVisitor;

class DimensionImpl {
public:
    virtual const Size& size() const noexcept = 0;
    virtual std::size_t hash() const noexcept = 0;
    virtual DimensionType type() const noexcept = 0;
    virtual bool is(DimensionTypeWithOrder ty) const noexcept {
        // This is not correct for MergeLikeOp! Handle that separately.
        return static_cast<DimensionTypeWithOrder>(type()) == ty;
    }
    virtual void accept(DimVisitor& visitor) const = 0;
    virtual const Color& getColor() const = 0;
    virtual ~DimensionImpl() = default;
};

class Dimension {
public:
    using PointerType = const DimensionImpl *;
protected:
    // Require that same `DimensionImpl`s have same address, i.e., uniqued.
    PointerType inner;
    std::size_t hashValue;
public:
    Dimension(PointerType inner, std::size_t hashValue): inner { inner }, hashValue { hashValue } {}
    Dimension(PointerType inner): inner { inner }, hashValue { inner->hash() } {}
    PointerType getInnerPointer() const noexcept { return inner; }
    const Size& size() const noexcept { return inner->size(); }
    DimensionType type() const noexcept { return inner->type(); }
    // Checks the underlying type of the dimension.
    bool is(DimensionType ty) const noexcept { return inner->type() == ty; }
    bool is(DimensionTypeWithOrder ty) const noexcept { return inner->is(ty); }
    template<typename T>
    const T& as() const noexcept { return *dynamic_cast<const T *>(inner); }
    template<typename T>
    const T *tryAs() const noexcept { return dynamic_cast<const T *>(inner); }
    bool operator==(const Dimension& other) const {
        return inner == other.inner; // If the impls are equal, they have equal hash.
    }
    // Sort the dimensions in an interface to obtain hash for it.
    std::size_t hash() const noexcept { return hashValue; }
    struct HashLessThan {
        bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.hash() < rhs.hash(); // We use hash to sort them.
        }
    };
    // This can be used to store temporary maps, which need not be preserved.
    struct AddressLessThan {
        bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.getInnerPointer() < rhs.getInnerPointer();
        }
    };

    // Color related.
    const Color& getColor() const { return inner->getColor(); }
    enum class Origin {
        Unfold,
        Input,
        Weight,
        BothPossible,
    };
    Origin deduceOrigin() const;

    // [<size>]@<type><hash>
    std::string description(const BindingContext& ctx) const;
    // All descendants.
    std::string descendantsDescription(const BindingContext& ctx) const;

    // FOR DEBUG USAGE ONLY!
    std::string debugDescription() const {
        if (BindingContext::DebugPublicCtx) {
            return description(*BindingContext::DebugPublicCtx);
        } else {
            return "NO_PUBLIC_CONTEXT";
        }
    }
    std::string debugDescendantsDescription() const {
        if (BindingContext::DebugPublicCtx) {
            return descendantsDescription(*BindingContext::DebugPublicCtx);
        } else {
            return "NO_PUBLIC_CONTEXT";
        }
    }
};

using ShapeView = AbstractShape<const std::vector<Dimension>&, [](const Dimension& dim) -> const Size& { return dim.size(); }>;

template<typename R>
concept DimensionRange =
    std::ranges::input_range<R> &&
    std::convertible_to<std::ranges::range_value_t<R>, Dimension>;

template<DimensionRange R>
std::string DimensionArrayToString(R&& interface, const BindingContext& ctx) {
    return fmt::format("[{}]", fmt::join(
        interface | std::views::transform([&ctx](auto&& dim) {
            return dim.description(ctx);
        }),
    ", "));
}

template<typename R>
concept TensorRange =
    std::ranges::input_range<R> &&
    DimensionRange<std::ranges::range_value_t<R>>;

template<TensorRange R>
std::string TensorArrayToString(R&& tensors, const BindingContext& ctx) {
    return fmt::format("{}", fmt::join(
        tensors | std::views::transform([&ctx](auto&& tensor) {
            return DimensionArrayToString(std::forward<decltype(tensor)>(tensor), ctx);
        }),
    ", "));
}

class Graph;

class Dimensions: public std::vector<Dimension> {
public:
    using std::vector<Dimension>::vector;

    std::size_t maximumTags() const;
    std::size_t countDataDiscardingDims() const;

    ShapeView getShape() const { return ShapeView(*this); }

    const_iterator binarySearch(const Dimension& value) const {
        return WeakOrderedBinarySearch(*this, value, Dimension::HashLessThan{});
    }
    iterator binarySearch(const Dimension& value) {
        auto it = std::as_const(*this).binarySearch(value);
        // Amazing trick: https://stackoverflow.com/questions/765148/how-to-remove-constness-of-const-iterator
        return erase(it, it);
    }
    std::size_t binarySearchIndexOf(const Dimension& value) const {
        return std::distance(begin(), binarySearch(value));
    }

    Dimensions substitute1to1(const Dimension& fro, const Dimension& to) const;
    Dimensions substitute1to2(const Dimension& fro, const Dimension& to1, const Dimension& to2) const;
    Dimensions substitute2to1(const Dimension& fro1, const Dimension& fro2, const Dimension& to) const;

    Graph buildGraph() const;

    auto filterOut(const std::vector<DimensionTypeWithOrder>& disallows) const {
        return *this | std::views::filter([&](const Dimension& dim) {
            return std::ranges::none_of(disallows, [&](auto disallow) { return dim.is(disallow); });
        });
    }
};

} // namespace kas

#define KAS_REPORT_DIMENSION_HASH_COLLISION(dim1, dim2) do { \
    KAS_WARNING("Duplicate dimensions! Or even worse, hash collision. {}", \
        ::kas::BindingContext::DebugPublicCtx != nullptr ? ::fmt::format("Maybe helpful: {} vs {}.", \
            (dim1).descendantsDescription(*::kas::BindingContext::DebugPublicCtx), \
            (dim2).descendantsDescription(*::kas::BindingContext::DebugPublicCtx)) \
        : "Please call Sampler._bind_debug_context() for more information."); \
} while (false)

template<>
struct std::hash<kas::Dimensions> {
    // Since this is a template function, std::hash<Dimensions> can provide hash for arbitrary DimensionRange.
    template<kas::DimensionRange R>
    std::size_t operator()(R&& interface) const noexcept {
        using namespace std::string_view_literals;
        std::size_t h = std::hash<std::string_view>{}("DimensionRange"sv);
        kas::HashCombine(h, interface.size());
        for (const kas::Dimension& dim: interface) {
            kas::HashCombineRaw(h, dim.hash());
        }
        return h;
    }
};

template<>
struct std::hash<std::vector<kas::Dimensions>> {
    // Since this is a template function, std::hash<std::vector<Dimensions>> can provide hash for arbitrary TensorRange.
    template<kas::TensorRange R>
    std::size_t operator()(R&& tensors) const noexcept {
        using namespace std::string_view_literals;
        std::size_t h = std::hash<std::string_view>{}("TensorRange"sv);
        kas::HashCombine(h, tensors.size());
        auto hasher = std::hash<kas::Dimensions>{};
        for (const auto& tensor: tensors) {
            kas::HashCombineRaw(h, hasher(tensor));
        }
        return h;
    }
};

template<>
struct fmt::formatter<kas::DimensionType>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::DimensionType t, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (t) {
        using enum kas::DimensionType;
        using namespace std::string_view_literals;
        case Shift:     name = "Shift"sv; break;
        case Stride:    name = "Stride"sv; break;
        case Split:     name = "Split"sv; break;
        case Unfold:    name = "Unfold"sv; break;
        case Merge:     name = "Merge"sv; break;
        case Share:     name = "Share"sv; break;
        case Iterator:  name = "Iterator"sv; break;
        case MapReduce: name = "MapReduce"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::DimensionType t);

template<>
struct fmt::formatter<kas::Direction>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Direction d, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (d) {
        using namespace std::string_view_literals;
        case kas::Direction::Down: name = "Down"sv; break;
        case kas::Direction::Up: name = "Up"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Direction d);

template<>
struct fmt::formatter<kas::Order>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Order o, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (o) {
        using namespace std::string_view_literals;
        case kas::Order::Left: name = "Left"sv; break;
        case kas::Order::Right: name = "Right"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Order o);

template<>
struct fmt::formatter<kas::Dimension::Origin>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Dimension::Origin o, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (o) {
        using namespace std::string_view_literals;
        case kas::Dimension::Origin::Input: name = "Input"sv; break;
        case kas::Dimension::Origin::Weight: name = "Weight"sv; break;
        case kas::Dimension::Origin::Unfold: name = "Unfold"sv; break;
        case kas::Dimension::Origin::BothPossible: name = "BothPossible"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Order o);

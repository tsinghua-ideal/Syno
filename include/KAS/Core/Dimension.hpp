#pragma once

#include <algorithm>
#include <compare>
#include <ranges>
#include <set>
#include <string>
#include <vector>

#include "fmt/format.h"

#include "KAS/Core/Colors.hpp"
#include "KAS/Core/Shape.hpp"
#include "KAS/Core/Size.hpp"
#include "KAS/Utils/Common.hpp"


namespace kas {

enum class DimensionType {
// Iterator:
    Iterator = 0,
// Hidden iterators generated by Reduce
    Reduce,
// Discarded iterators generated by Expand
    Expand,
// Repeat-like:
    Shift,
    Stride,
// Split-like:
    Split,
    Unfold,
// Merge-like:
    Merge,
    Share,
};
constexpr std::size_t DimensionTypeNum = 9;
inline std::size_t DimensionTypeHash(DimensionType type) {
    using namespace std::string_view_literals;
    constexpr int SizeTypeWidth = std::numeric_limits<std::size_t>::digits;
    constexpr int BitShift = SizeTypeWidth / DimensionTypeNum;
    static const std::array<std::size_t, DimensionTypeNum> DimensionTypeHashes = {
        std::rotl(std::hash<std::string_view>{}("DimensionType::Iterator"sv), 0 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Reduce"sv), 1 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Expand"sv), 2 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Shift"sv), 3 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Stride"sv), 4 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Split"sv), 5 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Unfold"sv), 6 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Merge"sv), 7 * BitShift),
        std::rotl(std::hash<std::string_view>{}("DimensionType::Share"sv), 8 * BitShift),
    };
    return DimensionTypeHashes[static_cast<std::size_t>(type)];
}

enum class DimensionTypeWithOrder {
    // Keep the 6 of them in the same order as DimensionType!
    Iterator = 0,
    Reduce,
    Expand,
    Shift,
    Stride,
    Split,
    Unfold,
    // MergeLikeOp's are different.
    MergeL,
    MergeR,
    ShareL,
    ShareR,
};

// A dimension connects two Op's. So there is a certain direction when we are traversing the graph.
enum class Direction: bool {
    Down = false,
    Up = true,
};

// Used to differentiate LHS from RHS.
enum class Order: bool {
    Left = false,
    Right = true,
};
constexpr std::string_view OrderToLR(Order order) {
    using namespace std::string_view_literals;
    switch (order) {
    case Order::Left: return "L"sv;
    case Order::Right: return "R"sv;
    default: return "Unknown"sv;
    }
}
// Implement functor.
constexpr std::optional<std::string_view> OrderToLR(std::optional<Order> order) {
    if (order.has_value()) {
        return OrderToLR(order.value());
    } else {
        return std::nullopt;
    }
}

class DimVisitor;
class PrimitiveOp;

class DimensionImpl {
public:
    virtual const Size& size() const = 0;
    virtual std::size_t hash() const noexcept = 0;
    virtual DimensionType type() const noexcept = 0;
    virtual bool is(DimensionTypeWithOrder ty) const noexcept {
        // This is not correct for MergeLikeOp! Handle that separately.
        return static_cast<DimensionTypeWithOrder>(type()) == ty;
    }
    virtual void accept(DimVisitor& visitor) const = 0;
    virtual const PrimitiveOp *getOpBelow() const = 0;
    virtual const Color& getColor() const = 0;
    virtual ~DimensionImpl() = default;
};

class Dimension {
public:
    using PointerType = const DimensionImpl *;
protected:
    // Require that same `DimensionImpl`s have same address, i.e., uniqued.
    PointerType inner;
    std::size_t hashValue;
public:
    Dimension(PointerType inner, std::size_t hashValue): inner { inner }, hashValue { hashValue } {}
    Dimension(PointerType inner): inner { inner }, hashValue { inner->hash() } {}
    PointerType getInnerPointer() const noexcept { return inner; }
    const Size& size() const { return inner->size(); }
    DimensionType type() const noexcept { return inner->type(); }
    // Checks the underlying type of the dimension.
    bool is(DimensionType ty) const noexcept { return inner->type() == ty; }
    bool is(DimensionTypeWithOrder ty) const noexcept { return inner->is(ty); }
    template<typename T>
    const T& as() const noexcept { return *dynamic_cast<const T *>(inner); }
    template<typename T>
    const T *tryAs() const noexcept { return dynamic_cast<const T *>(inner); }
    bool operator==(const Dimension& other) const {
        return inner == other.inner; // If the impls are equal, they have equal hash.
    }
    void accept(DimVisitor& visitor) const { inner->accept(visitor); }
    const PrimitiveOp *getOpBelow() const { return inner->getOpBelow(); }
    // Sort the dimensions in an interface to obtain hash for it.
    std::size_t hash() const noexcept { return hashValue; }
    struct HashLessThan {
        bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.hash() < rhs.hash(); // We use hash to sort them.
        }
    };
    // This can be used to store temporary maps, which need not be preserved.
    struct AddressLessThan {
        bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.getInnerPointer() < rhs.getInnerPointer();
        }
    };

    // Color related.
    const Color& getColor() const { return inner->getColor(); }
    enum class Origin {
        UnfoldOrExpand,
        Input,
        Weight,
        InputOrWeight,
    };
    Origin deduceOrigin() const;

    // [<size>]@<type><hash>
    std::string description(const BindingContext& ctx) const;
    // All descendants.
    std::string descendantsDescription(const BindingContext& ctx) const;

    // FOR DEBUG USAGE ONLY!
    std::string debugDescription() const;
    std::string debugDescendantsDescription() const;
};

using ShapeView = AbstractShape<const std::vector<Dimension>&, [](const Dimension& dim) -> const Size& { return dim.size(); }>;

template<typename R>
concept DimensionRange =
    std::ranges::input_range<R> &&
    std::convertible_to<std::ranges::range_value_t<R>, Dimension>;

template<DimensionRange R>
std::string DimensionArrayToString(R&& interface, const BindingContext& ctx) {
    return fmt::format("[{}]", fmt::join(
        interface | std::views::transform([&ctx](auto&& dim) {
            return dim.description(ctx);
        }),
    ", "));
}

template<DimensionRange R1, DimensionRange R2>
bool DimensionSetEqual(R1&& lhs, R2&& rhs) {
    using std::begin;
    using std::end;
    auto l = std::set<Dimension, Dimension::AddressLessThan>(begin(std::forward<R1>(lhs)), end(std::forward<R1>(lhs)));
    auto r = std::set<Dimension, Dimension::AddressLessThan>(begin(std::forward<R2>(rhs)), end(std::forward<R2>(rhs)));
    return l == r;
}

template<typename R>
concept TensorRange =
    std::ranges::input_range<R> &&
    DimensionRange<std::ranges::range_value_t<R>>;

template<TensorRange R>
std::string TensorArrayToString(R&& tensors, const BindingContext& ctx) {
    return fmt::format("{}", fmt::join(
        tensors | std::views::transform([&ctx](auto&& tensor) {
            return DimensionArrayToString(std::forward<decltype(tensor)>(tensor), ctx);
        }),
    ", "));
}

class Expand;
class Graph;

class Topmost;
template<typename R>
concept TopmostRange =
    std::ranges::input_range<R> &&
    std::convertible_to<std::ranges::range_value_t<R>, Topmost>;

class Topmost {
protected:
    std::vector<Dimension> interface;
    std::vector<const Expand *> expansions;

    std::vector<Dimension>::const_iterator binarySearch(const Dimension& value) const;
    std::vector<Dimension>::iterator binarySearch(const Dimension& value);
    std::size_t binarySearchIndexOf(const Dimension& value) const;

public:
    void sortDimensions();
    void sortExpansions();
    // This is required to make `interface` and `expansions` sorted for hashing.
    void sort();
    bool isSorted() const;

    explicit Topmost() = default;
    template<
        std::convertible_to<std::vector<Dimension>> I,
        std::convertible_to<std::vector<const Expand *>> E
    >
    explicit Topmost(I&& interface, E&& expansions):
        interface(std::forward<I>(interface)),
        expansions(std::forward<E>(expansions))
    {}
    Topmost(std::initializer_list<Dimension> interface, std::initializer_list<const Expand *> expansions):
        interface(interface),
        expansions(expansions)
    {}

    const std::vector<Dimension>& getDimensions() const { return interface; }
    std::vector<Dimension>& getDimensions() { return interface; }
    const std::vector<const Expand *>& getExpansions() const { return expansions; }
    std::vector<const Expand *>& getExpansions() { return expansions; }
    std::vector<Dimension> getAllDimensions() const;

    bool operator==(const Topmost& other) const = default;

    ShapeView getShape() const { return ShapeView(interface); }

    // E.g., [[H]@Merge0]{[k]@Merge1}, where the braces mean expansions.
    std::string description(const BindingContext& ctx) const;
    template<TopmostRange R>
    static std::string Description(R&& topmosts, const BindingContext& ctx) {
        return fmt::format("[{}]", fmt::join(
            topmosts
            | std::views::transform([&ctx](const Topmost& topmost) {
                return topmost.description(ctx);
            }),
            ", "
        ));
    }

    // FOR DEBUG USAGE ONLY!
    std::string debugDescription() const;
};

class GraphHandle: protected Topmost {
public:
    template<
        std::convertible_to<std::vector<Dimension>> I,
        std::convertible_to<std::vector<const Expand *>> E
    >
    explicit GraphHandle(I&& interface, E&& expansions):
        Topmost(
            std::forward<I>(interface),
            std::forward<E>(expansions)
        )
    {
        // So that we can use hash to identify this.
        sort();
    }
    template<typename T>
    explicit GraphHandle(T&& topmost):
        Topmost(std::forward<T>(topmost))
    {
        KAS_ASSERT(isSorted());
    }
    GraphHandle(std::initializer_list<Dimension> interface, std::initializer_list<const Expand *> expansions):
        Topmost(interface, expansions)
    {
        // So that we can use hash to identify this.
        sort();
    }
    // Merge them.
    static GraphHandle FromInterfaces(const std::vector<Topmost>& interfaces);

    const Topmost& getRaw() const { return *this; }
    const std::vector<Dimension>& getDimensions() const { return interface; }
    const std::vector<const Expand *>& getExpansions() const { return expansions; }
    using Topmost::getAllDimensions;

    bool operator==(const GraphHandle& other) const = default;

    using Topmost::getShape;

    using Topmost::description;

    bool contains(const Dimension& value) const { return binarySearch(value) != interface.end(); }
    GraphHandle insert1(const Dimension& value) const;
    GraphHandle moveToExpansions(const Expand *value) const;
    GraphHandle substitute1to1(const Dimension& fro, const Dimension& to) const;
    GraphHandle substitute1to2(const Dimension& fro, const Dimension& to1, const Dimension& to2) const;
    GraphHandle substitute2to1(const Dimension& fro1, const Dimension& fro2, const Dimension& to) const;

    Graph buildGraph() const;

    auto filterOut(std::vector<DimensionTypeWithOrder> disallows) const {
        return interface | std::views::filter([disallows=std::move(disallows)](const Dimension& dim) {
            return std::ranges::none_of(disallows, [&](auto disallow) { return dim.is(disallow); });
        });
    }
    auto filterIn(std::vector<DimensionTypeWithOrder> allows) const {
        return interface | std::views::filter([allows=std::move(allows)](const Dimension& dim) {
            return std::ranges::any_of(allows, [&](auto allow) { return dim.is(allow); });
        });
    }

    // FOR DEBUG USAGE ONLY!
    using Topmost::debugDescription;
};

class Reduce;

class Bottommost {
protected:
    std::vector<Dimension> output;
    std::vector<const Reduce *> reductions;

    // Move reductions to output.
    void extractReductions();

public:
    Bottommost() = default;
    template<
        std::convertible_to<std::vector<Dimension>> O,
        std::convertible_to<std::vector<const Reduce *>> R
    >
    Bottommost(O&& output, R&& reductions):
        output(std::forward<O>(output)),
        reductions(std::forward<R>(reductions))
    { extractReductions(); }
    template<std::convertible_to<std::vector<Dimension>> O>
    Bottommost(O&& output):
        output(std::forward<O>(output))
    { extractReductions(); }

    const std::vector<Dimension>& getOutput() const { return output; }
    std::vector<Dimension>& getOutput() { return output; }
    const std::vector<const Reduce *>& getReductions() const { return reductions; }
    std::vector<const Reduce *>& getReductions() { return reductions; }
    std::vector<Dimension> getAllDimensions() const;

    bool operator==(const Bottommost& other) const = default;

    Bottommost& operator+=(const Bottommost& other);
    Bottommost operator+(const Bottommost& other) const;

    // E.g., [[H]@Iterator0]{[k]@Reduce1}, where the braces mean reductions.
    std::string description(const BindingContext& ctx) const;

    // FOR DEBUG USAGE ONLY!
    std::string debugDescription() const;
};

} // namespace kas

#define KAS_REPORT_DIMENSION_HASH_COLLISION(dim1, dim2) do { \
    KAS_WARNING("Duplicate Dimension's! Or even worse, hash collision. {}", \
        ::kas::BindingContext::DebugPublicCtx != nullptr ? ::fmt::format("Maybe helpful: {} vs {}.", \
            (dim1).descendantsDescription(*::kas::BindingContext::DebugPublicCtx), \
            (dim2).descendantsDescription(*::kas::BindingContext::DebugPublicCtx)) \
        : "Please call Sampler._bind_debug_context() for more information."); \
} while (false)

template<>
struct std::hash<std::vector<kas::Dimension>> {
    // Since this is a template function, std::hash<std::vector<Dimension>> can provide hash for arbitrary DimensionRange.
    template<kas::DimensionRange R>
    std::size_t operator()(R&& interface) const noexcept {
        using namespace std::string_view_literals;
        static const auto drHash = std::hash<std::string_view>{}("DimensionRange"sv);
        auto h = drHash;
        kas::HashCombine(h, interface.size());
        for (const kas::Dimension& dim: interface) {
            kas::HashCombineRaw(h, dim.hash());
        }
        return h;
    }
};

template<>
struct std::hash<std::vector<std::vector<kas::Dimension>>> {
    // Since this is a template function, std::hash<std::vector<std::vector<Dimension>>> can provide hash for arbitrary TensorRange.
    template<kas::TensorRange R>
    std::size_t operator()(R&& tensors) const noexcept {
        using namespace std::string_view_literals;
        static const auto trHash = std::hash<std::string_view>{}("TensorRange"sv);
        auto h = trHash;
        kas::HashCombine(h, tensors.size());
        auto hasher = std::hash<std::vector<kas::Dimension>>{};
        for (const auto& tensor: tensors) {
            kas::HashCombineRaw(h, hasher(tensor));
        }
        return h;
    }
};

template<>
struct fmt::formatter<kas::DimensionType>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::DimensionType t, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (t) {
        using enum kas::DimensionType;
        using namespace std::string_view_literals;
        case Shift:     name = "Shift"sv; break;
        case Stride:    name = "Stride"sv; break;
        case Split:     name = "Split"sv; break;
        case Unfold:    name = "Unfold"sv; break;
        case Merge:     name = "Merge"sv; break;
        case Share:     name = "Share"sv; break;
        case Iterator:  name = "Iterator"sv; break;
        case Reduce: name = "Reduce"sv; break;
        case Expand:    name = "Expand"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::DimensionType t);

template<>
struct fmt::formatter<kas::Direction>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Direction d, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (d) {
        using namespace std::string_view_literals;
        case kas::Direction::Down: name = "Down"sv; break;
        case kas::Direction::Up: name = "Up"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Direction d);

template<>
struct fmt::formatter<kas::Order>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Order o, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (o) {
        using namespace std::string_view_literals;
        case kas::Order::Left: name = "Left"sv; break;
        case kas::Order::Right: name = "Right"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Order o);

template<>
struct fmt::formatter<kas::Dimension::Origin>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Dimension::Origin o, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (o) {
        using namespace std::string_view_literals;
        case kas::Dimension::Origin::Input: name = "Input"sv; break;
        case kas::Dimension::Origin::Weight: name = "Weight"sv; break;
        case kas::Dimension::Origin::UnfoldOrExpand: name = "UnfoldOrExpand"sv; break;
        case kas::Dimension::Origin::InputOrWeight: name = "InputOrWeight"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Order o);

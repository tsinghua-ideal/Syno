#pragma once

#include <algorithm>
#include <compare>
#include <ranges>
#include <string>
#include <vector>

#include "fmt/format.h"

#include "KAS/Core/Size.hpp"
#include "KAS/Utils/Common.hpp"


namespace kas {

enum class DimensionType {
// Repeat-like:
    Shift,
    Stride,
// Split-like:
    Split,
    Unfold,
// Merge-like:
    Merge,
    Share,
// Iterator:
    Iterator,
// Hidden iterators generated by MapReduce
    MapReduce,
};

// A dimension connects two Op's. So there is a certain direction when we are traversing the graph.
enum class Direction: bool {
    Down = false,
    Up = true,
};

// Used to differentiate LHS from RHS.
enum class Order: bool {
    Left = false,
    Right = true,
};

class DimVisitor;

class DimensionImpl {
public:
    virtual const Size& size() const noexcept = 0;
    virtual std::size_t hash() const noexcept = 0;
    virtual DimensionType type() const noexcept = 0;
    virtual void accept(DimVisitor& visitor) const = 0;
    virtual ~DimensionImpl() = default;
};

class Dimension;
using Interface = std::vector<Dimension>;

class Dimension {
public:
    using PointerType = const DimensionImpl *;
protected:
    // Require that same `DimensionImpl`s have same address, i.e., uniqued.
    PointerType inner;
    std::size_t hashValue;
public:
    inline Dimension(PointerType inner, std::size_t hashValue): inner { inner }, hashValue { hashValue } {}
    inline Dimension(PointerType inner): inner { inner }, hashValue { inner->hash() } {}
    inline PointerType getInnerPointer() const noexcept { return inner; }
    inline const Size& size() const noexcept { return inner->size(); }
    inline DimensionType type() const noexcept { return inner->type(); }
    // Checks the underlying type of the dimension.
    inline bool is(DimensionType ty) const noexcept { return inner->type() == ty; }
    template<typename T>
    const T& as() const noexcept { return *dynamic_cast<const T *>(inner); }
    template<typename T>
    const T *tryAs() const noexcept { return dynamic_cast<const T *>(inner); }
    inline bool operator==(const Dimension& other) const {
        return inner == other.inner; // If the impls are equal, they have equal hash.
    }
    // Sort the dimensions in an interface to obtain hash for it.
    inline std::size_t hash() const noexcept { return hashValue; }
    struct HashLessThan {
        inline bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.hash() < rhs.hash(); // We use hash to sort them.
        }
    };
    // This can be used to store temporary maps, which need not be preserved.
    struct AddressLessThan {
        inline bool operator()(const Dimension& lhs, const Dimension& rhs) const noexcept {
            return lhs.getInnerPointer() < rhs.getInnerPointer();
        }
    };
    // [<size>]@<type><hash>
    std::string description(const BindingContext& ctx) const;
    // All descendants.
    std::string descendantsDescription(const BindingContext& ctx) const;

    // FOR DEBUG USAGE ONLY!
    inline std::string debugDescription() const {
        if (BindingContext::DebugPublicCtx) {
            return description(*BindingContext::DebugPublicCtx);
        } else {
            return "NO_PUBLIC_CONTEXT";
        }
    }
    inline std::string debugDescendantsDescription() const {
        if (BindingContext::DebugPublicCtx) {
            return descendantsDescription(*BindingContext::DebugPublicCtx);
        } else {
            return "NO_PUBLIC_CONTEXT";
        }
    }
};

template<typename R>
concept DimensionRange =
    std::ranges::input_range<R> &&
    std::convertible_to<std::ranges::range_value_t<R>, Dimension>;

template<DimensionRange R>
std::string DimensionArrayToString(R&& interface, const BindingContext& ctx) {
    return fmt::format("[{}]", fmt::join(
        interface | std::views::transform([&ctx](auto&& dim) {
            return dim.description(ctx);
        }),
    ", "));
}

template<typename R>
concept TensorRange =
    std::ranges::input_range<R> &&
    DimensionRange<std::ranges::range_value_t<R>>;

template<TensorRange R>
std::string TensorArrayToString(R&& tensors, const BindingContext& ctx) {
    return fmt::format("{}", fmt::join(
        tensors | std::views::transform([&ctx](auto&& tensor) {
            return DimensionArrayToString(std::forward<decltype(tensor)>(tensor), ctx);
        }),
    ", "));
}

} // namespace kas

template<kas::DimensionRange DR>
struct std::hash<DR> {
    // Since this is a template function, std::hash<Interface> can provide hash for arbitrary DimensionRange.
    template<kas::DimensionRange R>
    inline std::size_t operator()(R&& interface) const noexcept {
        std::size_t h = interface.size();
        for (const auto& dim: interface) {
            kas::HashCombine(h, dim.hash());
        }
        return h;
    }
};

template<>
struct fmt::formatter<kas::DimensionType>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::DimensionType t, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (t) {
        using enum kas::DimensionType;
        using namespace std::literals;
        case Shift:     name = "Shift"sv; break;
        case Stride:    name = "Stride"sv; break;
        case Split:     name = "Split"sv; break;
        case Unfold:    name = "Unfold"sv; break;
        case Merge:     name = "Merge"sv; break;
        case Share:     name = "Share"sv; break;
        case Iterator:  name = "Iterator"sv; break;
        case MapReduce: name = "MapReduce"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::DimensionType t);

template<>
struct fmt::formatter<kas::Direction>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Direction d, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (d) {
        using namespace std::literals;
        case kas::Direction::Down: name = "Down"sv; break;
        case kas::Direction::Up: name = "Up"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Direction d);

template<>
struct fmt::formatter<kas::Order>: formatter<string_view> {
    template<typename FormatContext>
    auto format(kas::Order o, FormatContext& ctx) const {
        string_view name = "Unknown";
        switch (o) {
        using namespace std::literals;
        case kas::Order::Left: name = "Left"sv; break;
        case kas::Order::Right: name = "Right"sv; break;
        }
        return formatter<string_view>::format(name, ctx);
    }
};
std::ostream& operator<<(std::ostream& os, kas::Order o);

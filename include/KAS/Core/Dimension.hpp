#pragma once

#include <compare>
#include <string>
#include <vector>

#include "KAS/Core/Size.hpp"


namespace kas {

enum class DimensionType {
// Repeat-like:
    Shift,
    Stride,
// Split-like:
    Split,
    Unfold,
// Merge-like:
    Merge,
    Share,
// Iterator:
    Iterator,
// Hidden iterators generated by MapReduce
    MapReduce,
};
std::string DimensionTypeDescription(DimensionType ty);

class DimensionImpl {
public:
    virtual const Size& size() const noexcept = 0;
    virtual std::size_t initialHash() const noexcept = 0;
    virtual DimensionType type() const noexcept = 0;
    virtual ~DimensionImpl() = default;
};

class Dimension;
using Interface = std::vector<Dimension>;

class Dimension {
public:
    using PointerType = const DimensionImpl *;
protected:
    // Require that same `DimensionImpl`s have same address, i.e., uniqued.
    PointerType inner;
public:
    inline Dimension(PointerType inner): inner { inner } {}
    inline PointerType get() const noexcept { return inner; }
    inline const Size& size() const noexcept { return inner->size(); }
    inline DimensionType type() const noexcept { return inner->type(); }
    // Checks the underlying type of the dimension.
    inline bool is(DimensionType ty) const noexcept { return inner->type() == ty; }
    template<typename T>
    const T& as() const noexcept { return *dynamic_cast<const T *>(inner); }
    bool operator==(const Dimension& other) const = default;
    // Sort the dimensions in an interface to obtain hash for it.
    std::strong_ordering operator<=>(const Dimension& other) const = default;
    std::string description(const BindingContext& ctx) const;
};

} // namespace kas

template<>
struct std::hash<kas::Dimension> {
    inline std::size_t operator()(const kas::Dimension& dimension) const noexcept {
        return std::hash<kas::Dimension::PointerType>{}(dimension.get());
    }
};

template<>
struct std::hash<kas::Interface> {
    inline std::size_t operator()(const kas::Interface& interface) const noexcept {
        std::size_t h = interface.size();
        for (const auto& dim: interface) {
            kas::HashCombine(h, dim);
        }
        return h;
    }
};
